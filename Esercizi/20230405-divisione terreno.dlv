% == == == == == == == == == == == == == == == == == == == == == == == == == == == 
% Un caro amico di Ciccio Pasticcio, Goffredo Diseredo, è in difficoltà. Una lontana zia di cui nessuno ricordava
% l’esistenza ha lasciato in eredità a lui ed ai suoi 3 fratelli uno splendido terreno in campagna. All’iniziale
% euforia è seguito però un po’ di sconforto: la vecchia zia, infatti, ha specificato nel testamento che il terreno
% deve essere diviso in 4 parti, secondo alcune regole ben precise. Goffredo ed i suoi fratelli hanno provato a
% risolvere il problema, ma non riescono in alcun modo a venirne a capo. Hanno pertanto deciso di rivolgersi al
% nostro Ciccio, il quale, armato di un computer e della sua esperienza di modellazione ASP, è certo di venire a
% capo della questione in un lampo. Si aiuti Ciccio scrivendo un programma ASP adatto allo scopo, tenendo conto
% delle specifiche elencate di seguito.
% •	Il campo ereditato da Goffredo e i suoi Fratelli è quadrato, diviso in N*N lotti che formano una griglia.
% •	Il campo deve essere suddiviso in 4 sezioni, ciascuna contenente lo stesso numero di lotti.
% •	Tutti i lotti che formano una sezione devono essere contigui; in pratica, deve sempre essere possibile
%   passare da un lotto all’altro di una stessa sezione senza mai passare sul lotto di un’altra sezione.
% •	Nel campo sono presenti 4 querce su 4 lotti diversi: è obbligatorio che ogni lotto con una quercia finisca a
%   far parte di una sezione diversa: quindi ogni sezione avrà esattamente una quercia. La posizione delle quattro
%   querce è data in input sotto forma di 4 fatti.
% Esempio:  Si consideri, A PURO TITOLO DI ESEMPIO, il seguente campo, di 64 lotti, dove le querce sono indicate da 
% un asterisco (‘*’): le doppie linee al centro definiscono una possibile suddivisione ammissibile.

% |* |  |  |  ||  |  |  | *|
% -------------------------
% |  |  |  |  ||  |  |  |  |
% -------------------------
% |  |  |  |  ||  |  |  |  |
% -------------------------
% |  |  |  |  ||  |  |  |  |
% =========================
% |  |  |  |  ||  |  |  |  |
% -------------------------
% |  |  |  |  ||  |  |  |  |
% -------------------------
% |  |  |  |  ||  |  |  |  |
% -------------------------
% |* |  |  |  ||  |  |  | *|
% -------------------------

row(1..4).
col(1..4).
lot(R,C) :- row(R), col(C).
oak(1,1).
oak(4,4).
oak(4,1).
oak(2,2).

nSec(1..4).

section(S,R,C) | out(S,R,C) :- nSec(S), lot(R,C).
:- section(S1,R,C), section(S2,R,C), S1!=S2.

%% Non è possibile che ci siano due querce nella stessa sezione
:- oak(R1,C1), oak(R2,C2), section(S,R1,C1), section(S,R2,C2), R1<>R2.
:- oak(R1,C1), oak(R2,C2), section(S,R1,C1), section(S,R2,C2), C1<>C2.

%% Non è possibile che, preso un lotto, non ne esista almeno un altro nella stessa sezione su/giù e sinistra/destra
%:- section(S,R1,C1), not section(S,R2,C2), not section(S,R3,C3), R2=R1, R3=R1, C2=C1-1, C3=C1+1. 
%:- section(S,R1,C1), not section(S,R2,C2), not section(S,R3,C3), C2=C1, C3=C1, R2=R1-1, R3=R1+1. 
%:- section(S,R1,C1), not section(S,R2,C2), not section(S,R3,C3), not section(S,R4,C4), not section(S,R5,C5), R2=R1-1, C2=C1, R3=R1+1, C3=C1, R4=R1, C4=C1-1, R5=R1, C5=C1+1.

%% Non è possibile che le sezioni abbiano un numero di lotti differente
sectionDim(S,D):- section(S,_,_), #count{S,R,C : section(S,R,C)}=D.
%:- #count{D : sectionDim(_,D)}<>1.                                  % Se, tra le dim, ci fossero dim diverse, uscirebbe un numero maggiore di 1
%%% Oppure (più semplice)
:- sectionDim(S1,D1), sectionDim(S2,D2), S1<>S2, D1<>D2.

%% Non è possibile che ci sia una sezione mancante (devono essere 4)
generatedSect(S) :- sectionDim(S,_).
:- nSec(S), not generatedSect(S).

%% Non è possibile che la somma delle dimensioni delle sezioni, sia diversa dal numero di lotti
%% (Quindi non è possibile che ci siano lotti NON assegnati a sezioni) 
:- N=#count{R,C : lot(R,C)}, DimSum=#sum{D,S : sectionDim(S,D)}, N<>DimSum.

nLots(X) :- #count{R,C : lot(R,C)}=X.

hasContiguous(S,R1,C1) :- section(S,R1,C1), section(S,R2,C2), C2=C1+1, R2=R1.
hasContiguous(S,R1,C1) :- section(S,R1,C1), section(S,R2,C2), R2=R1+1, C2=C1.
hasContiguous(S,R2,C2) :- hasContiguous(S,R1,C1), section(S,R2,C2), C2=C1+1, R2=R1.
hasContiguous(S,R2,C2) :- hasContiguous(S,R1,C1), section(S,R2,C2), R2=R1+1, C2=C1.


nLastOfChain(X) :- #count{R,C : hasContiguous(_,R,C)}=X.

:- nLastOfChain(X), not nLots(X).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LA SOLUZIONE DI SOTTO FUNZIONA, MA SOLO CON MATRICI CHE HANNO %
%    NUM. RIGHE E NUM. COLONNE PARI, QUINDI SENZA LOTTI VUOTI   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 


%section(1,R,C) | section(2,R,C) | section(3,R,C) | section(4,R,C) :- lot(R,C).

%% Non è possibile che ci siano due querce nella stessa sezione
%:- oak(R1,C1), oak(R2,C2), section(S,R1,C1), section(S,R2,C2), R1<>R2.
%:- oak(R1,C1), oak(R2,C2), section(S,R1,C1), section(S,R2,C2), C1<>C2.

%% Non è possibile che, preso un lotto, non ne esista almeno un altro nella stessa sezione su/giù e sinistra/destra
%:- section(S,R1,C1), not section(S,R2,C2), not section(S,R3,C3), R2=R1, R3=R1, C2=C1-1, C3=C1+1. 
%:- section(S,R1,C1), not section(S,R2,C2), not section(S,R3,C3), C2=C1, C3=C1, R2=R1-1, R3=R1+1. 

%% Non è possibile che le sezioni abbiano un numero di lotti differente
%sectionDim(S,D):- section(S,_,_), #count{S,R,C : section(S,R,C)}=D.
%%:- #count{D : sectionDim(_,D)}<>1.                                  % Se, tra le dim, ci fossero dim diverse, uscirebbe un numero maggiore di 1
%%% Oppure (più semplice)
%:- sectionDim(S1,D1), sectionDim(S2,D2), S1<>S2, D1<>D2.